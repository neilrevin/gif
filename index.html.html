<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GIF Fusion Studio</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #ec4899;
            --accent: #14b8a6;
            --surface: rgba(255, 255, 255, 0.95);
            --surface-glass: rgba(255, 255, 255, 0.7);
            --text: #1e1b4b;
            --text-light: #6b7280;
            --border: rgba(99, 102, 241, 0.2);
            --shadow: 0 25px 50px -12px rgba(99, 102, 241, 0.25);
            --gradient-1: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-2: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --gradient-3: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --gradient-bg: linear-gradient(135deg, #1e1b4b 0%, #312e81 25%, #4c1d95 50%, #581c87 75%, #701a75 100%);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background: var(--gradient-bg);
            min-height: 100vh;
            color: var(--text);
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 20%, rgba(236, 72, 153, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(99, 102, 241, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 60%, rgba(20, 184, 166, 0.2) 0%, transparent 40%);
            pointer-events: none;
            z-index: 0;
        }

        .floating-orb {
            position: fixed;
            border-radius: 50%;
            filter: blur(60px);
            opacity: 0.6;
            animation: float 20s ease-in-out infinite;
            pointer-events: none;
            z-index: 0;
        }

        .orb-1 {
            width: 400px;
            height: 400px;
            background: var(--gradient-2);
            top: -100px;
            right: -100px;
            animation-delay: 0s;
        }

        .orb-2 {
            width: 300px;
            height: 300px;
            background: var(--gradient-3);
            bottom: -50px;
            left: -50px;
            animation-delay: -5s;
        }

        .orb-3 {
            width: 200px;
            height: 200px;
            background: var(--gradient-1);
            top: 50%;
            left: 50%;
            animation-delay: -10s;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0) scale(1); }
            25% { transform: translate(50px, -50px) scale(1.1); }
            50% { transform: translate(-30px, 30px) scale(0.9); }
            75% { transform: translate(30px, 50px) scale(1.05); }
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 40px 20px;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            margin-bottom: 50px;
            animation: slideDown 0.8s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .logo {
            display: inline-flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .logo-icon {
            width: 60px;
            height: 60px;
            background: var(--gradient-2);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 10px 40px rgba(236, 72, 153, 0.4);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .logo-icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        h1 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(135deg, #fff 0%, #e0e7ff 50%, #c7d2fe 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -1px;
        }

        .subtitle {
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.1rem;
            font-weight: 300;
            margin-top: 8px;
        }

        .main-card {
            background: var(--surface-glass);
            backdrop-filter: blur(20px);
            border-radius: 32px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: var(--shadow);
            overflow: hidden;
            animation: fadeUp 0.8s ease-out 0.2s both;
        }

        @keyframes fadeUp {
            from {
                opacity: 0;
                transform: translateY(40px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .upload-zone {
            padding: 60px 40px;
            text-align: center;
            border-bottom: 1px solid var(--border);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .upload-zone::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.05) 0%, rgba(236, 72, 153, 0.05) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .upload-zone:hover::before,
        .upload-zone.dragover::before {
            opacity: 1;
        }

        .upload-zone.dragover {
            border-color: var(--primary);
        }

        .upload-icon {
            width: 100px;
            height: 100px;
            margin: 0 auto 25px;
            background: var(--gradient-1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 15px 50px rgba(99, 102, 241, 0.3);
            transition: all 0.3s ease;
            position: relative;
        }

        .upload-zone:hover .upload-icon {
            transform: scale(1.1);
            box-shadow: 0 20px 60px rgba(99, 102, 241, 0.4);
        }

        .upload-icon svg {
            width: 40px;
            height: 40px;
            fill: white;
        }

        .upload-text {
            font-size: 1.25rem;
            color: var(--text);
            margin-bottom: 10px;
            font-weight: 500;
        }

        .upload-hint {
            color: var(--text-light);
            font-size: 0.95rem;
        }

        .upload-hint span {
            color: var(--primary);
            font-weight: 600;
            cursor: pointer;
            text-decoration: underline;
            text-underline-offset: 3px;
        }

        #fileInput {
            display: none;
        }

        .preview-section {
            padding: 30px;
            border-bottom: 1px solid var(--border);
            display: none;
        }

        .preview-section.active {
            display: block;
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .section-title {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--text);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title .icon {
            width: 28px;
            height: 28px;
            background: var(--gradient-3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .section-title .icon svg {
            width: 16px;
            height: 16px;
            fill: white;
        }

        .image-count {
            background: var(--gradient-1);
            color: white;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 15px;
            max-height: 400px;
            overflow-y: auto;
            padding: 5px;
        }

        .preview-grid::-webkit-scrollbar {
            width: 8px;
        }

        .preview-grid::-webkit-scrollbar-track {
            background: rgba(99, 102, 241, 0.1);
            border-radius: 4px;
        }

        .preview-grid::-webkit-scrollbar-thumb {
            background: var(--gradient-1);
            border-radius: 4px;
        }

        .preview-item {
            position: relative;
            aspect-ratio: 1;
            border-radius: 16px;
            overflow: hidden;
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            animation: scaleIn 0.4s ease-out;
        }

        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .preview-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(99, 102, 241, 0.2);
        }

        .preview-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .preview-item .order-badge {
            position: absolute;
            top: 8px;
            left: 8px;
            background: var(--gradient-1);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 700;
            box-shadow: 0 3px 10px rgba(99, 102, 241, 0.4);
        }

        .preview-item .filename {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            color: white;
            padding: 20px 8px 8px;
            font-size: 0.7rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .preview-item .remove-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 26px;
            height: 26px;
            background: rgba(239, 68, 68, 0.9);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(239, 68, 68, 0.4);
        }

        .preview-item:hover .remove-btn {
            opacity: 1;
        }

        .remove-btn:hover {
            transform: scale(1.1);
            background: #dc2626;
        }

        .settings-section {
            padding: 35px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.03) 0%, rgba(236, 72, 153, 0.03) 100%);
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
        }

        .setting-card {
            background: white;
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(99, 102, 241, 0.1);
            transition: all 0.3s ease;
        }

        .setting-card:hover {
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.15);
            transform: translateY(-2px);
        }

        .setting-label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            font-weight: 600;
            color: var(--text);
        }

        .setting-label .label-icon {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .setting-label .label-icon svg {
            width: 18px;
            height: 18px;
            fill: white;
        }

        .setting-label .label-icon.purple { background: var(--gradient-1); }
        .setting-label .label-icon.pink { background: var(--gradient-2); }
        .setting-label .label-icon.teal { background: var(--gradient-3); }
        .setting-label .label-icon.orange { background: linear-gradient(135deg, #f97316 0%, #fb923c 100%); }

        .custom-select {
            position: relative;
            width: 100%;
        }

        .custom-select select {
            width: 100%;
            padding: 14px 45px 14px 18px;
            font-size: 1rem;
            font-family: 'Outfit', sans-serif;
            border: 2px solid rgba(99, 102, 241, 0.2);
            border-radius: 14px;
            background: white;
            color: var(--text);
            cursor: pointer;
            appearance: none;
            transition: all 0.3s ease;
        }

        .custom-select select:hover {
            border-color: var(--primary);
        }

        .custom-select select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.15);
        }

        .custom-select::after {
            content: '';
            position: absolute;
            right: 18px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid var(--primary);
            pointer-events: none;
        }

        .size-inputs {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 12px;
            align-items: center;
        }

        .size-inputs input {
            width: 100%;
            padding: 14px;
            font-size: 1rem;
            font-family: 'Outfit', sans-serif;
            border: 2px solid rgba(99, 102, 241, 0.2);
            border-radius: 14px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .size-inputs input:hover {
            border-color: var(--primary);
        }

        .size-inputs input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.15);
        }

        .size-inputs .separator {
            font-size: 1.5rem;
            color: var(--text-light);
            font-weight: 300;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            padding: 12px 15px;
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .checkbox-item:hover {
            background: rgba(99, 102, 241, 0.05);
        }

        .checkbox-item input {
            display: none;
        }

        .checkbox-custom {
            width: 24px;
            height: 24px;
            border: 2px solid rgba(99, 102, 241, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .checkbox-item input:checked + .checkbox-custom {
            background: var(--gradient-1);
            border-color: transparent;
        }

        .checkbox-custom svg {
            width: 14px;
            height: 14px;
            fill: white;
            opacity: 0;
            transform: scale(0);
            transition: all 0.2s ease;
        }

        .checkbox-item input:checked + .checkbox-custom svg {
            opacity: 1;
            transform: scale(1);
        }

        .checkbox-text {
            font-weight: 500;
            color: var(--text);
        }

        .actions-section {
            padding: 30px 35px;
            background: white;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 16px 35px;
            font-size: 1rem;
            font-family: 'Outfit', sans-serif;
            font-weight: 600;
            border: none;
            border-radius: 14px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
        }

        .btn svg {
            width: 20px;
            height: 20px;
        }

        .btn-primary {
            background: var(--gradient-1);
            color: white;
            box-shadow: 0 10px 30px rgba(99, 102, 241, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(99, 102, 241, 0.4);
        }

        .btn-primary:active {
            transform: translateY(-1px);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: white;
            color: var(--text);
            border: 2px solid rgba(99, 102, 241, 0.2);
        }

        .btn-secondary:hover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.05);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            box-shadow: 0 10px 30px rgba(239, 68, 68, 0.3);
        }

        .btn-danger:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(239, 68, 68, 0.4);
        }

        .result-section {
            padding: 40px;
            text-align: center;
            display: none;
            border-top: 1px solid var(--border);
            background: linear-gradient(135deg, rgba(20, 184, 166, 0.05) 0%, rgba(99, 102, 241, 0.05) 100%);
        }

        .result-section.active {
            display: block;
            animation: fadeUp 0.5s ease-out;
        }

        .result-preview {
            max-width: 500px;
            margin: 0 auto 25px;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
            background: #f3f4f6;
        }

        .result-preview img {
            max-width: 100%;
            display: block;
        }

        .result-info {
            margin-bottom: 20px;
            color: var(--text-light);
        }

        .result-info strong {
            color: var(--text);
        }

        .progress-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(30, 27, 75, 0.9);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .progress-overlay.active {
            display: flex;
        }

        .progress-card {
            background: white;
            border-radius: 24px;
            padding: 50px 60px;
            text-align: center;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.3);
            animation: scaleIn 0.3s ease-out;
            min-width: 400px;
        }

        .progress-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto 25px;
            background: var(--gradient-1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .progress-icon svg {
            width: 36px;
            height: 36px;
            fill: white;
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .progress-text {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 8px;
        }

        .progress-subtext {
            color: var(--text-light);
            margin-bottom: 25px;
        }

        .progress-bar-container {
            background: rgba(99, 102, 241, 0.1);
            border-radius: 12px;
            height: 24px;
            overflow: hidden;
            position: relative;
            margin-bottom: 15px;
        }

        .progress-bar-fill {
            height: 100%;
            background: var(--gradient-1);
            border-radius: 12px;
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .progress-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-percentage {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 2rem;
            font-weight: 700;
            background: var(--gradient-1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--text);
            color: white;
            padding: 16px 30px;
            border-radius: 14px;
            font-weight: 500;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 1001;
            opacity: 0;
            transition: all 0.4s ease;
        }

        .toast.active {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }

        .toast.error {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }

        footer {
            text-align: center;
            padding: 40px 20px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
        }

        footer a {
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }

            .upload-zone {
                padding: 40px 20px;
            }

            .settings-section,
            .actions-section {
                padding: 25px 20px;
            }

            .settings-grid {
                grid-template-columns: 1fr;
            }

            .btn {
                width: 100%;
                justify-content: center;
            }
            
            .progress-card {
                min-width: auto;
                margin: 20px;
                padding: 30px;
            }
        }
    </style>
</head>
<body>
    <div class="floating-orb orb-1"></div>
    <div class="floating-orb orb-2"></div>
    <div class="floating-orb orb-3"></div>

    <div class="container">
        <header>
            <div class="logo">
                <div class="logo-icon">
                    <svg viewBox="0 0 24 24"><path d="M19.5 12c0-1.232-.046-2.453-.138-3.662a4.006 4.006 0 00-3.7-3.7 48.678 48.678 0 00-7.324 0 4.006 4.006 0 00-3.7 3.7c-.017.22-.032.441-.046.662M19.5 12l3-3m-3 3l-3-3m-12 3c0 1.232.046 2.453.138 3.662a4.006 4.006 0 003.7 3.7 48.656 48.656 0 007.324 0 4.006 4.006 0 003.7-3.7c.017-.22.032-.441.046-.662M4.5 12l3 3m-3-3l-3 3"/></svg>
                </div>
                <h1>GIF Fusion Studio</h1>
            </div>
            <p class="subtitle">Combine suas imagens em GIFs animados incr√≠veis</p>
        </header>

        <main class="main-card">
            <div class="upload-zone" id="uploadZone">
                <div class="upload-icon">
                    <svg viewBox="0 0 24 24"><path d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5"/></svg>
                </div>
                <p class="upload-text">Arraste e solte suas imagens aqui</p>
                <p class="upload-hint">ou <span onclick="document.getElementById('fileInput').click()">clique para selecionar</span></p>
                <input type="file" id="fileInput" multiple accept="image/*">
            </div>

            <div class="preview-section" id="previewSection">
                <div class="section-header">
                    <div class="section-title">
                        <div class="icon">
                            <svg viewBox="0 0 24 24"><path d="M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008V8.25zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z"/></svg>
                        </div>
                        Imagens (ordem alfab√©tica)
                    </div>
                    <span class="image-count" id="imageCount">0 imagens</span>
                </div>
                <div class="preview-grid" id="previewGrid"></div>
            </div>

            <div class="settings-section">
                <div class="section-header">
                    <div class="section-title">
                        <div class="icon">
                            <svg viewBox="0 0 24 24"><path d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.324.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 011.37.49l1.296 2.247a1.125 1.125 0 01-.26 1.431l-1.003.827c-.293.24-.438.613-.431.992a6.759 6.759 0 010 .255c-.007.378.138.75.43.99l1.005.828c.424.35.534.954.26 1.43l-1.298 2.247a1.125 1.125 0 01-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a6.57 6.57 0 01-.22.128c-.331.183-.581.495-.644.869l-.213 1.28c-.09.543-.56.941-1.11.941h-2.594c-.55 0-1.02-.398-1.11-.94l-.213-1.281c-.062-.374-.312-.686-.644-.87a6.52 6.52 0 01-.22-.127c-.325-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 01-1.369-.49l-1.297-2.247a1.125 1.125 0 01.26-1.431l1.004-.827c.292-.24.437-.613.43-.992a6.932 6.932 0 010-.255c.007-.378-.138-.75-.43-.99l-1.004-.828a1.125 1.125 0 01-.26-1.43l1.297-2.247a1.125 1.125 0 011.37-.491l1.216.456c.356.133.751.072 1.076-.124.072-.044.146-.087.22-.128.332-.183.582-.495.644-.869l.214-1.281z"/><path d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/></svg>
                        </div>
                        Configura√ß√µes do GIF
                    </div>
                </div>

                <div class="settings-grid">
                    <div class="setting-card">
                        <label class="setting-label">
                            <div class="label-icon purple">
                                <svg viewBox="0 0 24 24"><path d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                            </div>
                            Velocidade (segundos por frame)
                        </label>
                        <div class="custom-select">
                            <select id="frameDelay">
                                <option value="0.1">0.1 segundo (muito r√°pido)</option>
                                <option value="0.2">0.2 segundos</option>
                                <option value="0.3">0.3 segundos</option>
                                <option value="0.5" selected>0.5 segundos</option>
                                <option value="0.75">0.75 segundos</option>
                                <option value="1">1 segundo</option>
                                <option value="1.5">1.5 segundos</option>
                                <option value="2">2 segundos</option>
                                <option value="2.5">2.5 segundos</option>
                                <option value="3">3 segundos</option>
                                <option value="4">4 segundos</option>
                                <option value="5">5 segundos (muito lento)</option>
                            </select>
                        </div>
                    </div>

                    <div class="setting-card">
                        <label class="setting-label">
                            <div class="label-icon pink">
                                <svg viewBox="0 0 24 24"><path d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.894 20.567L16.5 21.75l-.394-1.183a2.25 2.25 0 00-1.423-1.423L13.5 18.75l1.183-.394a2.25 2.25 0 001.423-1.423l.394-1.183.394 1.183a2.25 2.25 0 001.423 1.423l1.183.394-1.183.394a2.25 2.25 0 00-1.423 1.423z"/></svg>
                            </div>
                            Qualidade
                        </label>
                        <div class="custom-select">
                            <select id="quality">
                                <option value="1">Baixa (arquivo menor)</option>
                                <option value="5">M√©dia</option>
                                <option value="10" selected>Alta</option>
                                <option value="15">Muito Alta</option>
                                <option value="20">M√°xima (arquivo maior)</option>
                            </select>
                        </div>
                    </div>

                    <div class="setting-card">
                        <label class="setting-label">
                            <div class="label-icon teal">
                                <svg viewBox="0 0 24 24"><path d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15"/></svg>
                            </div>
                            Tamanho do Canvas
                        </label>
                        <div class="custom-select">
                            <select id="canvasPreset">
                                <option value="800x800">Quadrado HD (800√ó800)</option>
                                <option value="1080x1080">Quadrado Full HD (1080√ó1080)</option>
                                <option value="1920x1080">Full HD Paisagem (1920√ó1080)</option>
                                <option value="1080x1920">Full HD Retrato (1080√ó1920)</option>
                                <option value="1280x720">HD 720p Paisagem (1280√ó720)</option>
                                <option value="720x1280">HD 720p Retrato (720√ó1280)</option>
                                <option value="500x500">Quadrado M√©dio (500√ó500)</option>
                                <option value="480x480">Quadrado Instagram (480√ó480)</option>
                                <option value="1200x628">Facebook Post (1200√ó628)</option>
                                <option value="1200x675">Twitter Post (1200√ó675)</option>
                                <option value="custom">‚úèÔ∏è Personalizado</option>
                            </select>
                        </div>
                        <div class="size-inputs" id="customSizeInputs" style="display: none; margin-top: 15px;">
                            <input type="number" id="canvasWidth" value="800" min="50" max="3000" placeholder="Largura">
                            <span class="separator">√ó</span>
                            <input type="number" id="canvasHeight" value="800" min="50" max="3000" placeholder="Altura">
                        </div>
                        <div class="size-display" style="margin-top: 12px; font-size: 0.9rem; color: var(--text-light);">
                            üìê Dimens√£o: <strong id="currentDimension">800 √ó 800 px</strong>
                        </div>
                    </div>

                    <div class="setting-card">
                        <label class="setting-label">
                            <div class="label-icon orange">
                                <svg viewBox="0 0 24 24"><path d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99"/></svg>
                            </div>
                            Op√ß√µes de Loop
                        </label>
                        <div class="checkbox-group">
                            <label class="checkbox-item">
                                <input type="checkbox" id="loopForever" checked>
                                <div class="checkbox-custom">
                                    <svg viewBox="0 0 24 24"><path d="M4.5 12.75l6 6 9-13.5"/></svg>
                                </div>
                                <span class="checkbox-text">Loop infinito</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" id="reversePlay">
                                <div class="checkbox-custom">
                                    <svg viewBox="0 0 24 24"><path d="M4.5 12.75l6 6 9-13.5"/></svg>
                                </div>
                                <span class="checkbox-text">Ida e volta (ping-pong)</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="actions-section">
                <button class="btn btn-primary" id="createGif" disabled>
                    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19.5 12c0-1.232-.046-2.453-.138-3.662a4.006 4.006 0 00-3.7-3.7 48.678 48.678 0 00-7.324 0 4.006 4.006 0 00-3.7 3.7c-.017.22-.032.441-.046.662M19.5 12l3-3m-3 3l-3-3m-12 3c0 1.232.046 2.453.138 3.662a4.006 4.006 0 003.7 3.7 48.656 48.656 0 007.324 0 4.006 4.006 0 003.7-3.7c.017-.22.032-.441.046-.662M4.5 12l3 3m-3-3l-3 3"/></svg>
                    Criar GIF
                </button>
                <button class="btn btn-secondary" id="clearAll" disabled>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0"/></svg>
                    Limpar Tudo
                </button>
            </div>

            <div class="result-section" id="resultSection">
                <div class="section-title" style="justify-content: center; margin-bottom: 25px;">
                    <div class="icon" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">
                        <svg viewBox="0 0 24 24"><path d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                    </div>
                    GIF Criado com Sucesso!
                </div>
                <div class="result-preview">
                    <img id="resultImage" src="" alt="GIF Result">
                </div>
                <p class="result-info" id="resultInfo"></p>
                <button class="btn btn-primary" id="downloadGif">
                    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3"/></svg>
                    Baixar GIF
                </button>
            </div>
        </main>

        <footer>
            <p>Feito com ‚ù§Ô∏è para criar GIFs incr√≠veis</p>
        </footer>
    </div>

    <div class="progress-overlay" id="progressOverlay">
        <div class="progress-card">
            <div class="progress-icon">
                <svg viewBox="0 0 24 24"><path d="M19.5 12c0-1.232-.046-2.453-.138-3.662a4.006 4.006 0 00-3.7-3.7 48.678 48.678 0 00-7.324 0 4.006 4.006 0 00-3.7 3.7c-.017.22-.032.441-.046.662M19.5 12l3-3m-3 3l-3-3m-12 3c0 1.232.046 2.453.138 3.662a4.006 4.006 0 003.7 3.7 48.656 48.656 0 007.324 0 4.006 4.006 0 003.7-3.7c.017-.22.032-.441.046-.662M4.5 12l3 3m-3-3l-3 3"/></svg>
            </div>
            <p class="progress-text">Criando seu GIF...</p>
            <p class="progress-subtext" id="progressStatus">Processando imagens</p>
            <div class="progress-bar-container">
                <div class="progress-bar-fill" id="progressBarFill"></div>
            </div>
            <div class="progress-percentage" id="progressPercentage">0%</div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        // GIF Encoder - Pure JavaScript implementation
        class GIFEncoder {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.frames = [];
                this.delay = 100;
                this.repeat = 0;
            }

            setDelay(ms) {
                this.delay = ms;
            }

            setRepeat(count) {
                this.repeat = count;
            }

            addFrame(canvas) {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, this.width, this.height);
                this.frames.push({
                    data: imageData.data,
                    delay: this.delay
                });
            }

            encode(progressCallback) {
                return new Promise((resolve) => {
                    const bytes = [];
                    
                    // GIF Header
                    this.writeString(bytes, 'GIF89a');
                    
                    // Logical Screen Descriptor
                    this.writeShort(bytes, this.width);
                    this.writeShort(bytes, this.height);
                    bytes.push(0xF7); // Global color table flag, 256 colors
                    bytes.push(0);    // Background color index
                    bytes.push(0);    // Pixel aspect ratio
                    
                    // Global Color Table (256 colors)
                    for (let i = 0; i < 256; i++) {
                        bytes.push(i, i, i);
                    }
                    
                    // Netscape Extension for looping
                    bytes.push(0x21, 0xFF, 0x0B);
                    this.writeString(bytes, 'NETSCAPE2.0');
                    bytes.push(0x03, 0x01);
                    this.writeShort(bytes, this.repeat);
                    bytes.push(0x00);
                    
                    // Process each frame
                    const totalFrames = this.frames.length;
                    let processedFrames = 0;
                    
                    const processFrame = (frameIndex) => {
                        if (frameIndex >= this.frames.length) {
                            // GIF Trailer
                            bytes.push(0x3B);
                            resolve(new Uint8Array(bytes));
                            return;
                        }
                        
                        const frame = this.frames[frameIndex];
                        
                        // Graphic Control Extension
                        bytes.push(0x21, 0xF9, 0x04);
                        bytes.push(0x04); // Disposal method
                        this.writeShort(bytes, Math.round(frame.delay / 10));
                        bytes.push(0x00); // Transparent color index
                        bytes.push(0x00);
                        
                        // Image Descriptor
                        bytes.push(0x2C);
                        this.writeShort(bytes, 0); // Left
                        this.writeShort(bytes, 0); // Top
                        this.writeShort(bytes, this.width);
                        this.writeShort(bytes, this.height);
                        bytes.push(0x00); // No local color table
                        
                        // LZW Minimum Code Size
                        const minCodeSize = 8;
                        bytes.push(minCodeSize);
                        
                        // Convert frame to indexed color and compress
                        const indexed = this.quantizeFrame(frame.data);
                        const compressed = this.lzwEncode(indexed, minCodeSize);
                        
                        // Write compressed data in sub-blocks
                        let offset = 0;
                        while (offset < compressed.length) {
                            const blockSize = Math.min(255, compressed.length - offset);
                            bytes.push(blockSize);
                            for (let i = 0; i < blockSize; i++) {
                                bytes.push(compressed[offset + i]);
                            }
                            offset += blockSize;
                        }
                        bytes.push(0x00); // Block terminator
                        
                        processedFrames++;
                        if (progressCallback) {
                            progressCallback(processedFrames / totalFrames);
                        }
                        
                        // Process next frame asynchronously
                        setTimeout(() => processFrame(frameIndex + 1), 0);
                    };
                    
                    processFrame(0);
                });
            }
            
            quantizeFrame(data) {
                const indexed = new Uint8Array(this.width * this.height);
                for (let i = 0; i < indexed.length; i++) {
                    const r = data[i * 4];
                    const g = data[i * 4 + 1];
                    const b = data[i * 4 + 2];
                    // Convert to grayscale-like palette index
                    indexed[i] = Math.round((r * 0.299 + g * 0.587 + b * 0.114));
                }
                return indexed;
            }
            
            lzwEncode(indexed, minCodeSize) {
                const clearCode = 1 << minCodeSize;
                const eoiCode = clearCode + 1;
                let codeSize = minCodeSize + 1;
                let nextCode = eoiCode + 1;
                const maxCode = 4096;
                
                const dictionary = new Map();
                for (let i = 0; i < clearCode; i++) {
                    dictionary.set(String(i), i);
                }
                
                const output = [];
                let bits = 0;
                let bitCount = 0;
                
                const writeBits = (code, size) => {
                    bits |= (code << bitCount);
                    bitCount += size;
                    while (bitCount >= 8) {
                        output.push(bits & 0xFF);
                        bits >>= 8;
                        bitCount -= 8;
                    }
                };
                
                writeBits(clearCode, codeSize);
                
                let current = String(indexed[0]);
                
                for (let i = 1; i < indexed.length; i++) {
                    const next = String(indexed[i]);
                    const combined = current + ',' + next;
                    
                    if (dictionary.has(combined)) {
                        current = combined;
                    } else {
                        writeBits(dictionary.get(current), codeSize);
                        
                        if (nextCode < maxCode) {
                            dictionary.set(combined, nextCode++);
                            if (nextCode > (1 << codeSize) && codeSize < 12) {
                                codeSize++;
                            }
                        } else {
                            writeBits(clearCode, codeSize);
                            dictionary.clear();
                            for (let j = 0; j < clearCode; j++) {
                                dictionary.set(String(j), j);
                            }
                            nextCode = eoiCode + 1;
                            codeSize = minCodeSize + 1;
                        }
                        
                        current = next;
                    }
                }
                
                writeBits(dictionary.get(current), codeSize);
                writeBits(eoiCode, codeSize);
                
                if (bitCount > 0) {
                    output.push(bits & 0xFF);
                }
                
                return output;
            }
            
            writeString(bytes, str) {
                for (let i = 0; i < str.length; i++) {
                    bytes.push(str.charCodeAt(i));
                }
            }
            
            writeShort(bytes, val) {
                bytes.push(val & 0xFF);
                bytes.push((val >> 8) & 0xFF);
            }
        }

        // Better GIF encoder using median cut quantization
        class AdvancedGIFEncoder {
            constructor(width, height, quality = 10) {
                this.width = width;
                this.height = height;
                this.quality = quality;
                this.frames = [];
                this.delay = 100;
                this.repeat = 0;
            }

            setDelay(ms) {
                this.delay = ms;
            }

            setRepeat(count) {
                this.repeat = count;
            }

            addFrame(imageData) {
                this.frames.push({
                    data: new Uint8Array(imageData),
                    delay: this.delay
                });
            }

            async encode(progressCallback) {
                const bytes = [];
                
                // Build color palette from first frame
                const palette = this.buildPalette(this.frames[0].data);
                
                // GIF Header
                this.writeString(bytes, 'GIF89a');
                
                // Logical Screen Descriptor
                this.writeShort(bytes, this.width);
                this.writeShort(bytes, this.height);
                bytes.push(0xF7); // Global color table, 256 colors, 8 bits
                bytes.push(0);    // Background
                bytes.push(0);    // Aspect ratio
                
                // Global Color Table
                for (let i = 0; i < 256; i++) {
                    if (i < palette.length) {
                        bytes.push(palette[i][0], palette[i][1], palette[i][2]);
                    } else {
                        bytes.push(0, 0, 0);
                    }
                }
                
                // Netscape Extension
                bytes.push(0x21, 0xFF, 0x0B);
                this.writeString(bytes, 'NETSCAPE2.0');
                bytes.push(0x03, 0x01);
                this.writeShort(bytes, this.repeat);
                bytes.push(0x00);
                
                // Encode frames
                for (let i = 0; i < this.frames.length; i++) {
                    const frame = this.frames[i];
                    
                    // Graphic Control Extension
                    bytes.push(0x21, 0xF9, 0x04, 0x04);
                    this.writeShort(bytes, Math.round(frame.delay / 10));
                    bytes.push(0x00, 0x00);
                    
                    // Image Descriptor
                    bytes.push(0x2C);
                    this.writeShort(bytes, 0);
                    this.writeShort(bytes, 0);
                    this.writeShort(bytes, this.width);
                    this.writeShort(bytes, this.height);
                    bytes.push(0x00);
                    
                    // LZW encode
                    const indexed = this.indexFrame(frame.data, palette);
                    const compressed = this.lzwEncode(indexed);
                    
                    bytes.push(8); // Min code size
                    
                    let pos = 0;
                    while (pos < compressed.length) {
                        const chunk = Math.min(255, compressed.length - pos);
                        bytes.push(chunk);
                        for (let j = 0; j < chunk; j++) {
                            bytes.push(compressed[pos++]);
                        }
                    }
                    bytes.push(0x00);
                    
                    if (progressCallback) {
                        progressCallback((i + 1) / this.frames.length);
                    }
                    
                    // Yield to prevent blocking
                    await new Promise(r => setTimeout(r, 0));
                }
                
                bytes.push(0x3B); // Trailer
                
                return new Uint8Array(bytes);
            }
            
            buildPalette(data) {
                const colorCounts = new Map();
                const step = Math.max(1, Math.floor(this.quality / 2));
                
                for (let i = 0; i < data.length; i += 4 * step) {
                    const r = data[i] & 0xF8;
                    const g = data[i + 1] & 0xF8;
                    const b = data[i + 2] & 0xF8;
                    const key = (r << 16) | (g << 8) | b;
                    colorCounts.set(key, (colorCounts.get(key) || 0) + 1);
                }
                
                const colors = Array.from(colorCounts.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 256)
                    .map(([key]) => [
                        (key >> 16) & 0xFF,
                        (key >> 8) & 0xFF,
                        key & 0xFF
                    ]);
                
                while (colors.length < 256) {
                    colors.push([0, 0, 0]);
                }
                
                return colors;
            }
            
            indexFrame(data, palette) {
                const indexed = new Uint8Array(this.width * this.height);
                const cache = new Map();
                
                for (let i = 0; i < indexed.length; i++) {
                    const r = data[i * 4];
                    const g = data[i * 4 + 1];
                    const b = data[i * 4 + 2];
                    const key = (r << 16) | (g << 8) | b;
                    
                    if (cache.has(key)) {
                        indexed[i] = cache.get(key);
                    } else {
                        let bestIndex = 0;
                        let bestDist = Infinity;
                        
                        for (let j = 0; j < palette.length; j++) {
                            const dr = r - palette[j][0];
                            const dg = g - palette[j][1];
                            const db = b - palette[j][2];
                            const dist = dr * dr + dg * dg + db * db;
                            
                            if (dist < bestDist) {
                                bestDist = dist;
                                bestIndex = j;
                            }
                        }
                        
                        cache.set(key, bestIndex);
                        indexed[i] = bestIndex;
                    }
                }
                
                return indexed;
            }
            
            lzwEncode(indexed) {
                const minCodeSize = 8;
                const clearCode = 256;
                const eoiCode = 257;
                
                let codeSize = minCodeSize + 1;
                let nextCode = 258;
                
                const dictionary = new Map();
                const output = [];
                let bits = 0;
                let bitCount = 0;
                
                const writeBits = (code, size) => {
                    bits |= code << bitCount;
                    bitCount += size;
                    while (bitCount >= 8) {
                        output.push(bits & 0xFF);
                        bits >>= 8;
                        bitCount -= 8;
                    }
                };
                
                const resetDictionary = () => {
                    dictionary.clear();
                    nextCode = 258;
                    codeSize = minCodeSize + 1;
                };
                
                writeBits(clearCode, codeSize);
                resetDictionary();
                
                let current = indexed[0];
                
                for (let i = 1; i < indexed.length; i++) {
                    const next = indexed[i];
                    const key = (current << 12) | next;
                    
                    if (dictionary.has(key)) {
                        current = dictionary.get(key);
                    } else {
                        writeBits(current, codeSize);
                        
                        if (nextCode < 4096) {
                            dictionary.set(key, nextCode++);
                            if (nextCode > (1 << codeSize) && codeSize < 12) {
                                codeSize++;
                            }
                        } else {
                            writeBits(clearCode, codeSize);
                            resetDictionary();
                        }
                        
                        current = next;
                    }
                }
                
                writeBits(current, codeSize);
                writeBits(eoiCode, codeSize);
                
                if (bitCount > 0) {
                    output.push(bits);
                }
                
                return output;
            }
            
            writeString(bytes, str) {
                for (const ch of str) {
                    bytes.push(ch.charCodeAt(0));
                }
            }
            
            writeShort(bytes, val) {
                bytes.push(val & 0xFF, (val >> 8) & 0xFF);
            }
        }

        // State
        let images = [];
        let gifBlob = null;

        // DOM Elements
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const previewSection = document.getElementById('previewSection');
        const previewGrid = document.getElementById('previewGrid');
        const imageCount = document.getElementById('imageCount');
        const createGifBtn = document.getElementById('createGif');
        const clearAllBtn = document.getElementById('clearAll');
        const resultSection = document.getElementById('resultSection');
        const resultImage = document.getElementById('resultImage');
        const resultInfo = document.getElementById('resultInfo');
        const downloadGifBtn = document.getElementById('downloadGif');
        const progressOverlay = document.getElementById('progressOverlay');
        const progressStatus = document.getElementById('progressStatus');
        const progressBarFill = document.getElementById('progressBarFill');
        const progressPercentage = document.getElementById('progressPercentage');
        const toast = document.getElementById('toast');

        // Settings elements
        const frameDelaySelect = document.getElementById('frameDelay');
        const qualitySelect = document.getElementById('quality');
        const canvasPresetSelect = document.getElementById('canvasPreset');
        const customSizeInputs = document.getElementById('customSizeInputs');
        const canvasWidthInput = document.getElementById('canvasWidth');
        const canvasHeightInput = document.getElementById('canvasHeight');
        const currentDimension = document.getElementById('currentDimension');
        const loopForeverCheckbox = document.getElementById('loopForever');
        const reversePlayCheckbox = document.getElementById('reversePlay');

        // Update progress bar
        function updateProgress(percent, status) {
            progressBarFill.style.width = percent + '%';
            progressPercentage.textContent = Math.round(percent) + '%';
            if (status) {
                progressStatus.textContent = status;
            }
        }

        // Handle canvas preset change
        function handleCanvasPresetChange() {
            const value = canvasPresetSelect.value;
            if (value === 'custom') {
                customSizeInputs.style.display = 'grid';
                updateDimensionDisplay();
            } else {
                customSizeInputs.style.display = 'none';
                const [w, h] = value.split('x');
                canvasWidthInput.value = w;
                canvasHeightInput.value = h;
                updateDimensionDisplay();
            }
            saveSettings();
        }

        // Update dimension display
        function updateDimensionDisplay() {
            currentDimension.textContent = `${canvasWidthInput.value} √ó ${canvasHeightInput.value} px`;
        }

        // Load saved settings
        function loadSettings() {
            const saved = localStorage.getItem('gifFusionSettings');
            if (saved) {
                const settings = JSON.parse(saved);
                frameDelaySelect.value = settings.frameDelay || '0.5';
                qualitySelect.value = settings.quality || '10';
                canvasPresetSelect.value = settings.canvasPreset || '800x800';
                canvasWidthInput.value = settings.canvasWidth || '800';
                canvasHeightInput.value = settings.canvasHeight || '800';
                loopForeverCheckbox.checked = settings.loopForever !== false;
                reversePlayCheckbox.checked = settings.reversePlay || false;
                
                if (settings.canvasPreset === 'custom') {
                    customSizeInputs.style.display = 'grid';
                } else {
                    customSizeInputs.style.display = 'none';
                }
                updateDimensionDisplay();
            }
        }

        // Save settings
        function saveSettings() {
            const settings = {
                frameDelay: frameDelaySelect.value,
                quality: qualitySelect.value,
                canvasPreset: canvasPresetSelect.value,
                canvasWidth: canvasWidthInput.value,
                canvasHeight: canvasHeightInput.value,
                loopForever: loopForeverCheckbox.checked,
                reversePlay: reversePlayCheckbox.checked
            };
            localStorage.setItem('gifFusionSettings', JSON.stringify(settings));
        }

        // Add change listeners
        canvasPresetSelect.addEventListener('change', handleCanvasPresetChange);
        
        canvasWidthInput.addEventListener('input', () => {
            updateDimensionDisplay();
            saveSettings();
        });
        
        canvasHeightInput.addEventListener('input', () => {
            updateDimensionDisplay();
            saveSettings();
        });

        [frameDelaySelect, qualitySelect, loopForeverCheckbox, reversePlayCheckbox].forEach(el => {
            el.addEventListener('change', saveSettings);
        });

        loadSettings();

        // Show toast
        function showToast(message, type = 'success') {
            toast.textContent = message;
            toast.className = 'toast ' + type;
            setTimeout(() => toast.classList.add('active'), 10);
            setTimeout(() => toast.classList.remove('active'), 3000);
        }

        // Drag and drop
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        uploadZone.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        // Handle files
        function handleFiles(files) {
            const validFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
            
            if (validFiles.length === 0) {
                showToast('Por favor, selecione apenas arquivos de imagem', 'error');
                return;
            }

            validFiles.forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    images.push({
                        name: file.name,
                        data: e.target.result
                    });
                    sortAndRenderImages();
                };
                reader.readAsDataURL(file);
            });
        }

        // Sort and render
        function sortAndRenderImages() {
            images.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
            renderPreviews();
            updateUI();
        }

        // Render previews
        function renderPreviews() {
            previewGrid.innerHTML = '';
            images.forEach((img, index) => {
                const item = document.createElement('div');
                item.className = 'preview-item';
                item.style.animationDelay = `${index * 0.05}s`;
                item.innerHTML = `
                    <img src="${img.data}" alt="${img.name}">
                    <div class="order-badge">${index + 1}</div>
                    <div class="filename">${img.name}</div>
                    <button class="remove-btn" onclick="removeImage(${index})">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                            <path d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    </button>
                `;
                previewGrid.appendChild(item);
            });
        }

        // Remove image
        function removeImage(index) {
            images.splice(index, 1);
            sortAndRenderImages();
            showToast('Imagem removida', 'success');
        }

        // Update UI
        function updateUI() {
            const hasImages = images.length > 0;
            previewSection.classList.toggle('active', hasImages);
            createGifBtn.disabled = images.length < 2;
            clearAllBtn.disabled = !hasImages;
            imageCount.textContent = `${images.length} ${images.length === 1 ? 'imagem' : 'imagens'}`;
            resultSection.classList.remove('active');
        }

        // Clear all
        clearAllBtn.addEventListener('click', () => {
            images = [];
            gifBlob = null;
            renderPreviews();
            updateUI();
            showToast('Todas as imagens foram removidas', 'success');
        });

        // Create GIF
        createGifBtn.addEventListener('click', async () => {
            if (images.length < 2) {
                showToast('Adicione pelo menos 2 imagens', 'error');
                return;
            }

            progressOverlay.classList.add('active');
            updateProgress(0, 'Iniciando...');

            try {
                const width = parseInt(canvasWidthInput.value) || 800;
                const height = parseInt(canvasHeightInput.value) || 800;
                const delay = parseFloat(frameDelaySelect.value) * 1000;
                const quality = parseInt(qualitySelect.value);
                const pingPong = reversePlayCheckbox.checked;

                updateProgress(5, 'Carregando imagens...');

                // Load images
                const loadedImages = [];
                for (let i = 0; i < images.length; i++) {
                    const img = await new Promise((resolve, reject) => {
                        const image = new Image();
                        image.onload = () => resolve(image);
                        image.onerror = reject;
                        image.src = images[i].data;
                    });
                    loadedImages.push(img);
                    updateProgress(5 + (i + 1) / images.length * 20, `Carregando imagem ${i + 1}/${images.length}...`);
                }

                updateProgress(25, 'Preparando encoder...');

                // Create encoder
                const encoder = new AdvancedGIFEncoder(width, height, quality);
                encoder.setDelay(delay);
                encoder.setRepeat(loopForeverCheckbox.checked ? 0 : 1);

                // Prepare frames
                let framesToAdd = [...loadedImages];
                if (pingPong && loadedImages.length > 2) {
                    const reversed = [...loadedImages].reverse().slice(1, -1);
                    framesToAdd = [...loadedImages, ...reversed];
                }

                updateProgress(30, 'Processando frames...');

                // Add frames
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                for (let i = 0; i < framesToAdd.length; i++) {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, width, height);

                    const img = framesToAdd[i];
                    const scale = Math.min(width / img.width, height / img.height);
                    const x = (width - img.width * scale) / 2;
                    const y = (height - img.height * scale) / 2;

                    ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
                    
                    const imageData = ctx.getImageData(0, 0, width, height);
                    encoder.addFrame(imageData.data);
                    
                    updateProgress(30 + (i + 1) / framesToAdd.length * 20, `Processando frame ${i + 1}/${framesToAdd.length}...`);
                }

                updateProgress(50, 'Renderizando GIF...');

                // Encode
                const gifData = await encoder.encode((progress) => {
                    updateProgress(50 + progress * 48, `Renderizando... ${Math.round(progress * 100)}%`);
                });

                // Create blob
                gifBlob = new Blob([gifData], { type: 'image/gif' });
                const url = URL.createObjectURL(gifBlob);
                resultImage.src = url;

                const sizeKB = (gifBlob.size / 1024).toFixed(1);
                const sizeMB = (gifBlob.size / 1024 / 1024).toFixed(2);
                const sizeText = gifBlob.size > 1024 * 1024 ? `${sizeMB} MB` : `${sizeKB} KB`;

                resultInfo.innerHTML = `<strong>${images.length} imagens</strong> ‚Ä¢ ${width}√ó${height}px ‚Ä¢ <strong>${sizeText}</strong> ‚Ä¢ ${parseFloat(frameDelaySelect.value)}s por frame`;

                updateProgress(100, 'Conclu√≠do!');

                setTimeout(() => {
                    resultSection.classList.add('active');
                    progressOverlay.classList.remove('active');
                    showToast('GIF criado com sucesso!', 'success');
                    resultSection.scrollIntoView({ behavior: 'smooth' });
                }, 500);

            } catch (error) {
                console.error('Erro:', error);
                progressOverlay.classList.remove('active');
                showToast('Erro ao criar o GIF. Tente novamente.', 'error');
            }
        });

        // Download
        downloadGifBtn.addEventListener('click', () => {
            if (!gifBlob) return;
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(gifBlob);
            link.download = `gif-fusion-${Date.now()}.gif`;
            link.click();
            showToast('Download iniciado!', 'success');
        });

        updateUI();
    </script>
</body>
</html>